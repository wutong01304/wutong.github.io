<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="wutong">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://wutong01304.github.io/2023/07/31/heap3/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="堆释放（Heap Release）是将已分配的堆内存返还给操作系统，以供其他部分使用。在C语言中，可以使用free()函数来释放动态分配的内存。堆释放的目的是为了释放无用的内存，避免内存泄漏和内存碎片问题，同时提高内存利用率。  一、__libc_free同malloc()函数一样，free()函数实际上是_libc_free()，其定义如下。 12345678910111213141516171">
<meta property="og:type" content="article">
<meta property="og:title" content="堆释放">
<meta property="og:url" content="https://wutong01304.github.io/2023/07/31/heap3/index.html">
<meta property="og:site_name" content="wutong">
<meta property="og:description" content="堆释放（Heap Release）是将已分配的堆内存返还给操作系统，以供其他部分使用。在C语言中，可以使用free()函数来释放动态分配的内存。堆释放的目的是为了释放无用的内存，避免内存泄漏和内存碎片问题，同时提高内存利用率。  一、__libc_free同malloc()函数一样，free()函数实际上是_libc_free()，其定义如下。 12345678910111213141516171">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h17.png?x-oss-process=style/watermark">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h18.png?x-oss-process=style/watermark">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h19.png?x-oss-process=style/watermark">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h20.png?x-oss-process=style/watermark">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h21.png?x-oss-process=style/watermark">
<meta property="article:published_time" content="2023-07-31T06:24:20.000Z">
<meta property="article:modified_time" content="2023-08-20T13:41:20.597Z">
<meta property="article:author" content="wutong">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="Basic Knowledge">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h17.png?x-oss-process=style/watermark">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-favicon.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-favicon.jpg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-favicon.jpg">
    <!--- Page Info-->
    
    <title>
        
            堆释放 -
        
        wutong
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"wutong01304.github.io","root":"/","language":"en"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":false,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":2,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":false,"site_pv":false,"site_uv":false,"post_pv":false},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"static","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"梧桐","subtitle":{"text":["梧桐生矣，于彼朝阳"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":false,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.2.1","navbar":{"auto_hide":false,"tags":{"Tags":{"icon":"fa-solid fa-tags","path":"/tags/"}},"categories":{"Categories":{"icon":"fa-solid fa-folder","path":"/categories/"}},"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Github":{"path":"https://github.com/wutong01304","icon":"github"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"cloud"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/7/1 11:45:14"};
    Global.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                wutong
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://github.com/wutong01304"  >
                                    
                                        
                                            <i class="github"></i>
                                        
                                        GITHUB
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://github.com/wutong01304"  >
                             
                                
                                    <i class="github"></i>
                                
                                GITHUB
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
             
                <div class="article-title">         
                    <img src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap3cover.jpg" alt="堆释放" />
                    <h1 class="article-title-cover">堆释放</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">wutong</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-07-31 14:24:20</span>
        <span class="mobile">2023-07-31 14:24</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-08-20 21:41:20</span>
            <span class="mobile">2023-08-20 21:41</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Study/">Study</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Pwn/">Pwn</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/heap/">heap</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Basic-Knowledge/">Basic Knowledge</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <p>堆释放（Heap Release）是将已分配的堆内存返还给操作系统，以供其他部分使用。在C语言中，可以使用free()函数来释放动态分配的内存。堆释放的目的是为了释放无用的内存，避免内存泄漏和内存碎片问题，同时提高内存利用率。</p>
<hr>
<h1 id="一、-libc-free"><a href="#一、-libc-free" class="headerlink" title="一、__libc_free"></a>一、__libc_free</h1><p>同malloc()函数一样，free()函数实际上是_libc_free()，其定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem) &#123;</span><br><span class="line">    mstate    ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">//chunk的mem指针  </span></span><br><span class="line">    <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__free_hook);<span class="comment">//全局变量__free_hook 赋给了局部变量 hook</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;<span class="comment">//判断__free_hook是否有值</span></span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));<span class="comment">//有值就当成函数指针使用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">// mem为0,free没有作用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p = mem2chunk(mem);<span class="comment">// 将mem转换为chunk状态    </span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">// 如果该块内存是mmap得到的</span></span><br><span class="line">    &#123;<span class="comment">//mp_.no_dyn_threshold变量标志着是否启用了动态调整阈值机制。如果它为true，则不需要执行后续代码，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;<span class="comment">//比较释放内存块p的大小</span></span><br><span class="line">            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;<span class="comment">//MAX此次最大允许动态阈值调整的上限</span></span><br><span class="line">            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;<span class="comment">//nomask(p)的大小不在规定范围内或没有符合条件的内存块空闲，不会进行后续操作。</span></span><br><span class="line">            mp_.mmap_threshold = chunksize(p);<span class="comment">//符合条件的内存块空闲，就将动态阈值设置为当前内存块大小</span></span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;<span class="comment">//避免频繁释放和重新分配中产生的内存碎片</span></span><br><span class="line">            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,<span class="comment">//调用LIBC_PROBE()函数触发性能事件通知</span></span><br><span class="line">                       mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;<span class="comment">//此代码段用于启用和更新内存分配器的动态阈值机制，并触发有关性能和状态的事件通知</span></span><br><span class="line">        munmap_chunk(p);<span class="comment">//就调用munmap释放它</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ar_ptr = arena_for_chunk(p);<span class="comment">// 根据chunk获得分配区的指针    </span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);<span class="comment">// 执行释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里主要关注__free_hook和_int_free函数，free_hook函数在后续溢出get_shell的时候会遇到，_int_free则是后续执行free的主体。</p>
<hr>
<h1 id="二、-int-free"><a href="#二、-int-free" class="headerlink" title="二、_int_free"></a>二、_int_free</h1><p>首先定义一系列所需的变量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock) &#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* 释放的chunk的size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* 对应的fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* 内存空间中下一个chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* 下一个chunk的大小 */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* 下一个chunk是否在使用 */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* 内存空间中上一个chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;   <span class="comment">/* 保存错误的指针 */</span></span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;              <span class="comment">/* 初始化locked */</span></span><br><span class="line">  size = chunksize (p);        <span class="comment">/*获取chunk的size */</span></span><br></pre></td></tr></table></figure></div>

<p>对chunk做—些检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>) || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>)) &#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;<span class="comment">//指针不能指向非法的地址, 指针必须得对齐</span></span><br><span class="line">errout:</span><br><span class="line">  <span class="keyword">if</span> (!have_lock &amp;&amp; locked)<span class="comment">//在当前尚未获取锁但是之前已经加过锁时</span></span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<span class="comment">//解锁</span></span><br><span class="line">  malloc_printerr (check_action, errstr, chunk2mem (p), av);<span class="comment">//打印错误信息</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123;<span class="comment">//chunk的大小必须大于等于MINSIZE且对齐</span></span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line">check_inuse_chunk(av, p);<span class="comment">//检查该chunk是否处于使用状态</span></span><br></pre></td></tr></table></figure></div>

<p>然后，判断该chunk是否在fast bin范围内，如果是，就插入到fast bin中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS<span class="comment">//默认 #define TRIM_FASTBINS 0，因此默认情况下下面的语句不会执行    </span></span></span><br><span class="line">   &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<span class="comment">//不会将靠近top chunk的fast bin删掉</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> )&#123;<span class="comment">//当前free的chunk属于fastbin   </span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (<span class="comment">// 下一个chunk的大小不能小于两倍的SIZE_SZ</span></span><br><span class="line">		chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || </span><br><span class="line">		__builtin_expect (<span class="comment">//下一个chunk的大小不能大于system_mem</span></span><br><span class="line">			chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (have_lock || (&#123; <span class="comment">//如果已经获取锁</span></span><br><span class="line">			assert (locked == <span class="number">0</span>); <span class="comment">//还未加锁</span></span><br><span class="line">			mutex_lock(&amp;av-&gt;mutex);<span class="comment">//加锁</span></span><br><span class="line">			locked = <span class="number">1</span>;<span class="comment">//将locked设置为1以表示此时Arena被锁定</span></span><br><span class="line">			chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || <span class="comment">//chunk大小不合法</span></span><br><span class="line">				chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">		  &#125;)) &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (! have_lock) &#123;<span class="comment">//未被锁定且当前线程已获取了该链表所对应的锁</span></span><br><span class="line">	      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<span class="comment">//释放分配区的锁</span></span><br><span class="line">	      locked = <span class="number">0</span>;<span class="comment">//将locked设置为0以表示此时Arena未被锁定</span></span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//将chunk的mem部分全部设置为perturb_byte</span></span><br><span class="line">    set_fastchunks(av);<span class="comment">//设置fast chunk的标记位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">// 根据大小获取fast bin的索引</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);<span class="comment">// 获取对应fastbin的头指针，被初始化后为NULL</span></span><br><span class="line">    mchunkptr old = *fb, old2;<span class="comment">// 执行 *fb 语句获取当前空闲链表指针的值，并将其赋值给 old2 变量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;<span class="comment">//声明并初始化一个名为 old_idx 的 unsigned int 类型局部变量</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>)) &#123;<span class="comment">// 防止对 fast bin double free</span></span><br><span class="line">	      errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)<span class="comment">//如果当前线程持有锁并且链表不为空</span></span><br><span class="line">	      old_idx = fastbin_index(chunksize(old));<span class="comment">//计算所处空闲链表索</span></span><br><span class="line">	    p-&gt;fd = old2 = old;<span class="comment">//将当前释放的内存块 p 插入到链表头部</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<span class="comment">//操作失败则需要重复操作直至成功</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>)) &#123;<span class="comment">// 确保fast bin的加入前与加入后相同</span></span><br><span class="line">	    errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;<span class="comment">//如果当前线程持有锁并且链表不为空且没有正确插入</span></span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></div>

<p>如果该chunk并非mmap()生成的，就需要进行合并。先向后合并，再向前合并。在没有锁的情况下，先获得锁，然后确认该chunk可以合并。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) </span><br><span class="line">&#123;<span class="comment">//不属于fast chunk且当前free的chunk不是通过mmap分配的		  </span></span><br><span class="line">     <span class="keyword">if</span> (! have_lock) &#123;<span class="comment">//并且当前还没有获得分配区的锁</span></span><br><span class="line">       (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);<span class="comment">//获取分配区的锁 </span></span><br><span class="line">        locked = <span class="number">1</span>;<span class="comment">//将locked设置为1以表示此时Arena被锁定</span></span><br><span class="line">   &#125;		</span><br><span class="line">   nextchunk = chunk_at_offset(p, size);<span class="comment">//获取下一块chunk的地址</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) &#123;<span class="comment">//free的是top chunk     </span></span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av) &amp;&amp; <span class="comment">//当前free的chunk的下一个chunk不能超过arena的边界</span></span><br><span class="line">	 (<span class="type">char</span> *) nextchunk &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>)) &#123;    </span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) &#123;<span class="comment">//该chunk已经是free状态      </span></span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">   &#125;</span><br><span class="line">   nextsize = chunksize(nextchunk);<span class="comment">//获取下一个chunk的大小		</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || <span class="comment">//查看下一个相邻的chunk的大小是否合法</span></span><br><span class="line">	__builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;<span class="comment">//或是否大于分配区所分配的内存总量     </span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">   &#125;</span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//将指针的mem部分全部设置为perturb_byte</span></span><br></pre></td></tr></table></figure></div>

<p>之后进行合并。向后合并、向前合并、unlink单独介绍。如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD，那就向系统返还内存。一般合并到 top chunk 都会执行这部分代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) </span><br><span class="line">	&#123;<span class="comment">//当前free的chunk不属于fastbin   </span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))<span class="comment">// 如果有 fast chunk </span></span><br><span class="line">	      malloc_consolidate(av);<span class="comment">//就用malloc_consolidate进行合并</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;<span class="comment">//chunk主分配区</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM<span class="comment">//如果定义了该宏，则表示不支持在 main arena 上进行 heap 内存的收缩操作</span></span></span><br><span class="line">	      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">          <span class="comment">//如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用systrim函数收缩heap</span></span><br><span class="line">	        systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//为非主分配区,调用heap_trim函数收缩非主分配区的sub_heap        </span></span><br><span class="line">	      heap_info *heap = heap_for_ptr(top(av));<span class="comment">//通过top获取 heap 的地址</span></span><br><span class="line">	      assert(heap-&gt;ar_ptr == av);<span class="comment">//确保 ar_ptr指向正确 </span></span><br><span class="line">	      heap_trim(heap, mp_.top_pad);<span class="comment">//heap空间的收缩操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;<span class="comment">//未被锁定且当前线程已获取了该链表所对应的锁    </span></span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<span class="comment">//释放分配区的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则调用munma_chunk释放    </span></span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a><strong>整体流程：</strong></h2><p>①如果在 fastbin 范围则加入到 fast bin 头部并返回。否则转下一步。</p>
<p>②如果不是 mmap 申请的内存，就进行合并。先向后合并，再向前合并。</p>
<p>③如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD 就向系统返还内存。否则调用munmap_chunk 释放 chunk。</p>
<hr>
<h1 id="三、unlink"><a href="#三、unlink" class="headerlink" title="三、unlink"></a>三、unlink</h1><p>unlink在合并和切割remainder时会用到。先介绍unlink，基础unlink代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))<span class="comment">//检查当前size和nextchunk的prevsize是否相同</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">  FD = p-&gt;fd;<span class="comment">//获取p的下一个空闲块指针</span></span><br><span class="line">  BK = p-&gt;bk;<span class="comment">//获取p的上一个空闲块指针</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != p || BK-&gt;fd != p, <span class="number">0</span>))<span class="comment">//检查下一个chunk的bk指针和上一个chunk的fd指针是否指向p</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">  FD-&gt;bk = BK;<span class="comment">//将下一个chunk的bk指针指向上一个chunk</span></span><br><span class="line">  BK-&gt;fd = FD;<span class="comment">//将上一个chunk的fd指针指向下一个chunk</span></span><br></pre></td></tr></table></figure></div>

<p>1、首先，检查当前内存块 P 的大小与下一个内存块的 prev_size 是否一致。如果不一致，表示堆数据结构出现了错误。</p>
<p>2、保存当前内存块 P 的前驱和后继节点的指针到 BK 和 FD 变量中。</p>
<p>3、检查前驱节点的 bk 指针和后继节点的 fd 指针是否正确指向当前内存块 P。如果不正确，表示双向链表的链接关系出现了错误。</p>
<p>4、如果前驱和后继节点的链接关系正确，就将前驱节点的 bk 指针指向后继节点，后继节点的 fd 指针指向前驱节点。即将当前内存块 P 从双向链表中移除。</p>
<p>如图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h17.png?x-oss-process=style/watermark"
                     
                ></p>
<p>剩余代码如下:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)<span class="comment">//如果当前内存块 P 为large chunk。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p <span class="comment">//检查p的下一个大小不同的空闲chunk的bk_nextsize指针是否指向p</span></span><br><span class="line">          || p-&gt;bk_nextsize-&gt;fd_nextsize != p)<span class="comment">//检查p的上一个大小不同的空闲chunk的fd_nextsize指针是否指向p</span></span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)<span class="comment">//判断下一个chunk是否为lagre chunk（只有p在lagre bin）</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;fd_nextsize == p)<span class="comment">//如果p的fd_nextsiz指向自己（large bin只有一个large chunk）</span></span><br><span class="line">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;<span class="comment">//将下一个空闲块fd_nextsize、bk_nextsize都指向它本身</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              FD-&gt;fd_nextsize = p-&gt;fd_nextsize;<span class="comment">//将下一个chunk的fd_nextsize指向p的fd_nextsize</span></span><br><span class="line">              FD-&gt;bk_nextsize = p-&gt;bk_nextsize;<span class="comment">//将下一个chunk的bk_nextsize指向p的fd_nextsize</span></span><br><span class="line">              p-&gt;fd_nextsize-&gt;bk_nextsize = FD;<span class="comment">//将p的下一块大小不同的chunk的bk_nextsize指向下一块chunk</span></span><br><span class="line">              p-&gt;bk_nextsize-&gt;fd_nextsize = FD;<span class="comment">//将p的上一块大小不同的chunk的fd_nextsize指向p的下一块chunk</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;                                              <span class="comment">//在lagre bin链条上</span></span><br><span class="line">          p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;<span class="comment">//将p的下一块chunk的bk_nextsize指向p的上一块chunk</span></span><br><span class="line">          p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<span class="comment">//将p的上一块chunk的fd_nextsize指向p的下一块chunk</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>5、判断它是否在large bin的链表中。即当前内存块 P 不属于小型内存块范围（in_smallbin_range），并且具有 fd_nextsize 指针。在的话转到第6步，不在就结束程序。</p>
<p>6、检查 P 的fd_nextsize、bk_nextsize是否正确链接到前后节点。如果不正确，表示大型large bin的链接关系出现错误。</p>
<p>7、判断下一个chunk的fd_nextsize是否为空。即判断P是否是当前链表中的唯一一个在large bin中的空闲块。如果不是，转到第10步。</p>
<p>8、判断p的下一个大小不同的空闲块是否指向自身，即判断是否是large bin中唯一一个chunk。如果是，将下一个空闲块fd_nextsize、bk_nextsize都指向它本身，即重新初始化large bin。</p>
<p>9、否则，将下一个空闲块fd_nextsize、bk_nextsize指向p的fd_nextsize、bk_nextsize，将lagre bin上p的前后节点都指向下一个空闲块。(使p的下一块chunk替代p)</p>
<p>10、将前驱节点的 bk_nextsize 指针指向后继节点，后继节点的 fd_nextsize 指针指向前驱节点。即将当前内存块 P 从large bin中移除。</p>
<hr>
<h1 id="四、向后合并"><a href="#四、向后合并" class="headerlink" title="四、向后合并"></a>四、向后合并</h1><p>合并<strong>低地址处</strong>相邻的chunk，会先更新 p 的 size 以及指向，然后调用 unlink() 宏将 chunk 从其链接的 bin 中脱链。代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">	prevsize = p-&gt;prev_size;<span class="comment">//获取前一块的size</span></span><br><span class="line">    size += prevsize;<span class="comment">//更新size</span></span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="comment">//获得前一块chunk的指针，更新p</span></span><br><span class="line">    unlink(av, p, bck, fwd);<span class="comment">//脱链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>①检查当前chunk的前一块chunk是否是free（检查p的previnuse位是否为0）（如果空闲就返回为真，进行向后合并)</p>
<p>②获取前一块chunk的size，并更新size</p>
<p>③通过减p-&gt;prev_size来获得指向前一块chunk的指针，chunk_at_offset将p+size这段内存强制看成一个chunk结构体。</p>
<p>④把p指向的块进行脱链，也就是前一块chunk进行unlink</p>
<p>如图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h18.png?x-oss-process=style/watermark"
                     
                ></p>
<p>在这里值得注意的是，这里的size是一个变量，P-&gt;size并没有发生改变；其次chunk_at_offset只是返回一个地址（指针），即只是P的指向改变了，其它内存布局都没有变。后续会在向前合并中，通过set_head来改变内存布局（一定会发生）。</p>
<hr>
<h1 id="五、向前合并"><a href="#五、向前合并" class="headerlink" title="五、向前合并"></a>五、向前合并</h1><p>合并<strong>高地址</strong>处相邻的chunk。<strong>如果向前相邻</strong> <strong>top_chunk****，则直接合并到</strong> <strong>top_chunk****。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	...</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	size += nextsize;<span class="comment">//更新size</span></span><br><span class="line">	set_head(p, size | PREV_INUSE);<span class="comment">//设置状态位P为1</span></span><br><span class="line">	av-&gt;top = p;<span class="comment">//更新p</span></span><br><span class="line">	check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该操作会将size加上top chunk的size，通过set_head将p、size和状态位设置到内存块头部（top chunk的PREV_INUSE始终为1），然后将top chunk指针指向p。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h19.png?x-oss-process=style/watermark"
                     
                ></p>
<p><strong>如果向前不相邻</strong> <strong>top_chunk，则尝试向前合并后插入到 unsorted_bin</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//检测nextchunk是否已经free</span></span><br><span class="line">	<span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">		unlink(av, nextchunk, bck, fwd);<span class="comment">//是的话就将nextchunk脱链</span></span><br><span class="line">		size += nextsize;<span class="comment">//更新size</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//没有free的就修改nextchunk状态位P为0</span></span><br><span class="line">	bck = unsorted_chunks(av);<span class="comment">//获取unsorted_bin指针</span></span><br><span class="line">	fwd = bck-&gt;fd;<span class="comment">//下一个bin指针</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<span class="comment">//判断unsorted是否被破坏</span></span><br><span class="line">		malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">	p-&gt;fd = fwd;<span class="comment">//修改p的指针</span></span><br><span class="line">	p-&gt;bk = bck;</span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range(size))&#123;<span class="comment">//是large_bin就设置fd_nextsize、bk_nextsize</span></span><br><span class="line">		p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;<span class="comment">//双向链，unsorted指针指向p</span></span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line">    set_head(p, size | PREV_INUSE);<span class="comment">//将size以及状态位设置到内存块头部</span></span><br><span class="line">    set_foot(p, size);<span class="comment">//size检查，也就是内存完整性检查</span></span><br><span class="line"> 	check_free_chunk(av, p);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>检测nextchunk是否free，是通过inuse_bit_at_offset(nextchunk, nextsize)来获得nextchunk的相邻下一块chunk的的PREV_INUSE（P）位实现的。P为 0就表示已经被free，就进入unlink流程。如果nextchunk不是free，就修改nextchunk的PREV_INUSE（P）为0，表示当前chunk是free的。</p>
<p>执行前：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h20.png?x-oss-process=style/watermark"
                     
                ></p>
<p>执行后：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h21.png?x-oss-process=style/watermark"
                     
                ></p>
<p>如果可以向前合并就合并，不论是否合并，都会将其插入到unsorted_bin中，然后执行set_head和set_foot，来重设chunk。</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 堆释放</li>
        <li><strong>Author:</strong> wutong</li>
        <li><strong>Created at:</strong> 2023-07-31 14:24:20</li>
        
            <li>
                <strong>Updated at:</strong> 2023-08-20 21:41:20
            </li>
        
        <li>
            <strong>Link:</strong> https://wutong01304.github.io/2023/07/31/heap3/
        </li>
        <li>
            <strong>License:</strong> This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Pwn/">#Pwn</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/heap/">#heap</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/Basic-Knowledge/">#Basic Knowledge</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/08/02/one/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">off-by-one</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/07/29/heap2/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">堆分配</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">堆释放</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81-libc-free"><span class="nav-text">一、__libc_free</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-int-free"><span class="nav-text">二、_int_free</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-text">整体流程：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81unlink"><span class="nav-text">三、unlink</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%90%91%E5%90%8E%E5%90%88%E5%B9%B6"><span class="nav-text">四、向后合并</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%90%91%E5%89%8D%E5%90%88%E5%B9%B6"><span class="nav-text">五、向前合并</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">wutong</a>
        </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br>
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.1</a>
        </div>
        
        
        
        
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>





    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>






  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>







<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
