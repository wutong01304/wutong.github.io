<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="wutong">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://wutong01304.github.io/2023/07/29/heap2/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="堆分配（Heap Allocation）是一种内存分配方式，它允许程序在运行时动态分配和释放内存。与静态内存分配方式不同，堆分配不需要在编译时确定内存分配的大小，而是可以在程序运行时根据需要动态地分配和回收内存。在堆分配中，内存被划分为一系列大小不同的堆块。当程序需要动态分配内存时，可以使用堆管理器（Heap Manager）来分配一个适当大小的堆块，以满足程序的需求。当程序不再需要分配的内存时，">
<meta property="og:type" content="article">
<meta property="og:title" content="堆分配">
<meta property="og:url" content="https://wutong01304.github.io/2023/07/29/heap2/index.html">
<meta property="og:site_name" content="wutong">
<meta property="og:description" content="堆分配（Heap Allocation）是一种内存分配方式，它允许程序在运行时动态分配和释放内存。与静态内存分配方式不同，堆分配不需要在编译时确定内存分配的大小，而是可以在程序运行时根据需要动态地分配和回收内存。在堆分配中，内存被划分为一系列大小不同的堆块。当程序需要动态分配内存时，可以使用堆管理器（Heap Manager）来分配一个适当大小的堆块，以满足程序的需求。当程序不再需要分配的内存时，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h14.png?x-oss-process=style/watermark">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h15.png?x-oss-process=style/watermark">
<meta property="og:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h16.png?x-oss-process=style/watermark">
<meta property="article:published_time" content="2023-07-29T11:42:22.000Z">
<meta property="article:modified_time" content="2023-08-20T13:19:37.252Z">
<meta property="article:author" content="wutong">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="Basic Knowledge">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h14.png?x-oss-process=style/watermark">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-favicon.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-favicon.jpg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-favicon.jpg">
    <!--- Page Info-->
    
    <title>
        
            堆分配 -
        
        wutong
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"wutong01304.github.io","root":"/","language":"en"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":false,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":2,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":false,"site_pv":false,"site_uv":false,"post_pv":false},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"static","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"梧桐","subtitle":{"text":["梧桐生矣，于彼朝阳"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":false,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.2.1","navbar":{"auto_hide":false,"tags":{"Tags":{"icon":"fa-solid fa-tags","path":"/tags/"}},"categories":{"Categories":{"icon":"fa-solid fa-folder","path":"/categories/"}},"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Github":{"path":"https://github.com/wutong01304","icon":"github"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"cloud"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/7/1 11:45:14"};
    Global.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                wutong
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://github.com/wutong01304"  >
                                    
                                        
                                            <i class="github"></i>
                                        
                                        GITHUB
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://github.com/wutong01304"  >
                             
                                
                                    <i class="github"></i>
                                
                                GITHUB
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
             
                <div class="article-title">         
                    <img src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap2cover.jpg" alt="堆分配" />
                    <h1 class="article-title-cover">堆分配</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/my-logo-avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">wutong</span>
                            
                                <span class="author-label">Lv3</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-07-29 19:42:22</span>
        <span class="mobile">2023-07-29 19:42</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-08-20 21:19:37</span>
            <span class="mobile">2023-08-20 21:19</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Study/">Study</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Pwn/">Pwn</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/heap/">heap</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Basic-Knowledge/">Basic Knowledge</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <p>堆分配（Heap Allocation）是一种内存分配方式，它允许程序在运行时动态分配和释放内存。与静态内存分配方式不同，堆分配不需要在编译时确定内存分配的大小，而是可以在程序运行时根据需要动态地分配和回收内存。在堆分配中，内存被划分为一系列大小不同的堆块。当程序需要动态分配内存时，可以使用堆管理器（Heap Manager）来分配一个适当大小的堆块，以满足程序的需求。当程序不再需要分配的内存时，可以请求堆管理器释放该内存。</p>
<h1 id="一、堆初始化"><a href="#一、堆初始化" class="headerlink" title="一、堆初始化"></a>一、堆初始化</h1><p>在第一次调用malloc的时候，此时内存中各个bin还未初始化。系统会先执行**__libc_malloc**函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化。</p>
<h2 id="1-1-libc-malloc"><a href="#1-1-libc-malloc" class="headerlink" title="1.1 __libc_malloc"></a>1.1 __libc_malloc</h2><p>__libc_malloc 是内存分配的底层函数，它可以直接在堆上分配指定大小的内存块。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">	mstate ar_ptr;</span><br><span class="line">	<span class="type">void</span> *victim;</span><br><span class="line">	<span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)<span class="comment">// 判断__malloc_hook中是否有值，有值就当成函数指针调用 </span></span><br><span class="line">		= atomic_forced_read (__malloc_hook);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">	arena_get (ar_ptr, bytes);<span class="comment">// 获取分配区指针，并锁住分配区内存</span></span><br><span class="line">	victim = _int_malloc (ar_ptr, bytes);<span class="comment">//分配内存</span></span><br><span class="line">	<span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)<span class="comment">// 内存分配失败，尝试寻找其他可用的arena进行分配 </span></span><br><span class="line">	&#123;</span><br><span class="line">		LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">		ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">		victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)<span class="comment">//解除分配区内存锁</span></span><br><span class="line">		(<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">	assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || <span class="comment">//mem2chunk,根据 mem 地址得到 chunk 地址</span></span><br><span class="line">	ar_ptr == arena_for_chunk (mem2chunk (victim)));<span class="comment">//通过倒数第二个比特位判断内存属性 </span></span><br><span class="line">	<span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>程序第一次运行__libc_malloc时，__malloc_hook中的值是hook.c中的malloc_hook_ini函数（如下图），因此会调用该函数，用于对__malloc_hook进行初始化，初始化结束后值为NULL，然后回调__libc_malloc。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span> <span class="comment">//hook是一个函数指针变量，被赋值成了__malloc_hook</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span></span><br><span class="line">&#123;<span class="comment">//保证在多次调用__libc_malloc的情况下，代码中的hook回调函数只会被调用一次</span></span><br><span class="line">	__malloc_hook = <span class="literal">NULL</span>;			<span class="comment">//将__malloc_hook置0</span></span><br><span class="line">	ptmalloc_init ();				<span class="comment">//初始化ptmalloc</span></span><br><span class="line">	<span class="keyword">return</span> __libc_malloc (sz);		<span class="comment">//回到__libc_malloc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>紧接着对管理器会调用arena_get 获取到管理空闲空间的分配区地址，然后调用_int_malloc分配内存。其中**_int_malloc**是内存分配的核心函数，将在堆分配章节介绍。</p>
<h2 id="1-2-malloc-consolidate"><a href="#1-2-malloc-consolidate" class="headerlink" title="1.2 malloc_consolidate"></a>1.2 malloc_consolidate</h2><p>在分配了一些初始内存块后，可能会存在一些相邻的空闲块。为了提高内存的利用效率，malloc_consolidate 函数会对这些相邻的空闲块进行合并，以形成更大的连续可用空间。因此，malloc_consolidate 通常会在 __libc_malloc 执行后被调用，以优化堆的内存布局。</p>
<p>malloc_consolidate() 函数是定义在 malloc.c 中的一个函数，用于将 fastbin 中的空闲 chunk 合并整理到 unsorted_bin 中以及进行<strong>初始化堆</strong>的工作，在 malloc() 以及 free() 中均有可能调用 malloc_consolidate() 函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast ( != <span class="number">0</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	malloc_init_state(av); <span class="comment">//堆初始化</span></span><br><span class="line">	check_malloc_state(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如代码所示，进入 malloc_consolidate()，当进程第一次调用 malloc() 申请分配的时候，get_max_fast() 返回值等于 0。</p>
<p>首先通过 get_max_fast()判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins，再初始化fast bins。在初次初始化完成时，unsorted bin是空的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line">	<span class="comment">//对每个bin进行初始化操作</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;<span class="comment">//遍历bins中的每个bin</span></span><br><span class="line">        bin = bin_at (av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;<span class="comment">//将fd和bk指针指向对应的bin</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    set_noncontiguous(av);</span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">        set_max_fast(DEFAULT_MXFAST);<span class="comment">//设置对应的fast chunk的尺寸</span></span><br><span class="line">    av-&gt;flags |= FASTCHUNKS_BIT;<span class="comment">//设置arena的flags字段表明初始化了fastbins</span></span><br><span class="line">    av-&gt;top = initial_top (av);<span class="comment">//用initial_top初始化top chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果 get_max_fast() 返回值不等于 0，说明堆已经初始化，就会<strong>清空</strong> <strong>fastbin</strong>，将 fastbin 中的每一个 chunk 合并整理到 unsorted_bin 或 top_chunk。</p>
<p><strong>malloc_consolidate总体流程如下</strong>：</p>
<ol>
<li>若 get_max_fast() 返回 0，则进行堆的初始化工作，然后进入第 7 步</li>
<li>从 fastbin 中获取一个空闲 chunk</li>
<li>尝试向后合并 前一个chunk非free的，不会发生向后合并操作</li>
<li>若向前相邻 top_chunk，则直接合并到 top_chunk，然后进入第 6 步</li>
<li>否则尝试向前合并后，插入到 unsorted_bin 中</li>
<li>获取下一个空闲 chunk，回到第 2 步，直到所有 fastbin 清空后进入第 7 步</li>
<li>退出函数</li>
</ol>
<p><strong>流程图：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h14.png?x-oss-process=style/watermark"
                     
                ></p>
<p>malloc_consolidate()了解到这里就可以了。这里提到的向后合并和向前合并将在另一篇<a href="https://wutong01304.github.io/2023/07/31/heap3/">堆释放</a>进行介绍。</p>
<hr>
<h1 id="二、堆分配"><a href="#二、堆分配" class="headerlink" title="二、堆分配"></a>二、堆分配</h1><h2 id="2-1-代码分析"><a href="#2-1-代码分析" class="headerlink" title="2.1 代码分析"></a>2.1 代码分析</h2><p><strong>_int_malloc</strong>是内存分配的核心函数，总结在末尾，以下是代码分析： </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 对齐后的所需内存大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 保存所需chunk在bins中的下标 */</span>/</span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 保存bin */</span></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 保存chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 保存chunk的size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 保存chunk在bins中的下标 */</span></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 保存chunk分配内存后剩余内存的指针 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 保存剩余部分内存大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* 已分配内存块的块 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* 二进制映射指针 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 二进制映射的当前字 */</span></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 保存chunk的fd指针 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 保存chunk的bk指针 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;        <span class="comment">/* 保存错误的指针 */</span></span><br><span class="line">  checked_request2size (bytes, nb); <span class="comment">/* 取得对齐后的size值 */</span></span><br></pre></td></tr></table></figure></div>

<p>首先定义一系列所需的变量，checked_request2size (bytes, nb)将申请的字节数bytes根据2*SIZE_SZ对齐转换成实际分配的字节数nb，并做了一些安全检查，确保不会溢出。</p>
<p>如果没有合适的arena，就调用sysmalloc，用mmap分配chunk并返回。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有合适的arena，就调用sysmalloc，用mmap分配chunk并返回。</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))<span class="comment">//av是__libc_malloc中调用arena_get获得的分配区指针</span></span><br><span class="line">    &#123;<span class="comment">//如果为null，就表示没有分配区可用</span></span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);<span class="comment">//调用sysmalloc通过mmap获取chunk</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">         alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化操作。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>其次，检查fastbin中是否有合适的chunk。如果需要分配的内存大小nb落在fastbin的范围内,那么尝试从 fast bins 中分配 chunk</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果需要分配的内存大小nb落在fastbin的范围内,那么尝试从 fast bins 中 分配 chunk </span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;<span class="comment">//get_max_fast返回fastbin可以存储内存的最大值，它在ptmalloc的初始化函数malloc_init_state中定义。</span></span><br><span class="line">      idx = fastbin_index (nb);<span class="comment">//获取fastbin索引</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//根据idx获取对应链表的头指针    </span></span><br><span class="line">      mchunkptr pp = *fb;<span class="comment">//获取对应大小的fatbin的链表中的第一个空闲的chunk</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;<span class="comment">//将链表的第一个chunk作为victim取出，插入时也插入在链表头，即LIFO</span></span><br><span class="line">          victim = pp;<span class="comment">//victim是我们取出的chunk的地址</span></span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//pp  == victim 导致循环退出</span></span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);<span class="comment">//catomic_compare将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)</span></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//检查索引和size是否正确</span></span><br><span class="line">		  &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<span class="comment">//打印错误信息。</span></span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//把chunk的指针转换成mem的指针</span></span><br><span class="line">          alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，检查small bin中是否有合适的chunk。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))<span class="comment">//如果 nb 属于 smallbins</span></span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);<span class="comment">//获得索引</span></span><br><span class="line">     bin = bin_at (av, idx);<span class="comment">//通过idx获取对应的small bin链表表头指针</span></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">// 获取对应链表的最后一个chunk,</span></span><br><span class="line">     &#123;<span class="comment">//如果victim等于表头，表示该链表为空，跳过下面部分</span></span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">//victim为0表示smallbin还未初始化</span></span><br><span class="line">           malloc_consolidate (av);<span class="comment">//调用malloc_consolidate完成初始化操作</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">            bck = victim-&gt;bk;<span class="comment">//获取此chunk的上一个chunk的地址             </span></span><br><span class="line">   	     <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))             </span><br><span class="line">            &#123;<span class="comment">//检查victim上一个chunk的fd是否与victim相等</span></span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">             &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);<span class="comment">//将下一个相邻的chunk的 inuse bit 为 1             </span></span><br><span class="line">             bin-&gt;bk = bck;<span class="comment">//将bin从链表中取出，相当于unlink</span></span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//如果不是主线程则设置NON_MAIN_ARENA位</span></span><br><span class="line">             check_malloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//将chunk指针转化为mem指针</span></span><br><span class="line">             alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果fast bin、small bin都不能满足，就调用malloc_consolidate整理fastbins。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span><span class="comment">//若所需大小不属于small bins，则可能位于large bins中</span></span><br><span class="line">   &#123;</span><br><span class="line">     idx = largebin_index (nb);<span class="comment">//获取对应大小的large bin的索引</span></span><br><span class="line">     <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">//检查fastbin链表是否为空，</span></span><br><span class="line">     	 malloc_consolidate (av);<span class="comment">//整理 fastbins</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后进入一个外层for循环，包含了_int_malloc之后的所有过程。紧接着是内层第一个while循环，遍历unsorted bin中的每一个chunk，如果大小正好合适，就将其取出，否则就将其放入small bin或者large bin。这是唯一将chunk放进small bin或者large bin的过程。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))         </span><br><span class="line">     &#123;<span class="comment">//如果链表不为空，则循环遍历 unsorted 所有的chunk</span></span><br><span class="line">         bck = victim-&gt;bk;<span class="comment">//获取下一块chunk</span></span><br><span class="line">         <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) <span class="comment">//判断chunk大小是否合法</span></span><br><span class="line">			|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))<span class="comment">//如果不合法就打印错误信息</span></span><br><span class="line">				malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem (victim), av);</span><br><span class="line">	  size = chunksize (victim);     <span class="comment">//若合法则取出size位</span></span><br></pre></td></tr></table></figure></div>

<p>在内层第一个循环内部，当请求的chunk属于smallbin、unsortedbin只有一个chunk为last remainder并且满足拆分条件时，就将其拆分。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; <span class="comment">//如果要申请的大小在smallbin范围</span></span><br><span class="line">         bck == unsorted_chunks (av) &amp;&amp; <span class="comment">// 且 unsorted chunks 只有一个chunk</span></span><br><span class="line">         victim == av-&gt;last_remainder &amp;&amp; <span class="comment">//且victim是last_remainder</span></span><br><span class="line">         (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))<span class="comment">//chunk 的大小可以进行切割</span></span><br><span class="line">&#123;<span class="comment">//分割reminder，并将新的reminder插入到unsorted bin中</span></span><br><span class="line">         remainder_size = size - nb;<span class="comment">//计算剩下reminder的大小</span></span><br><span class="line">         remainder = chunk_at_offset (victim, nb);<span class="comment">//获取剩下的reminder的地址</span></span><br><span class="line">         unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<span class="comment">//将新的reminder插入到unsorted bin中</span></span><br><span class="line">         av-&gt;last_remainder = remainder;<span class="comment">//last_reminder重新指向新的reminder</span></span><br><span class="line">         remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<span class="comment">//新reminder的fd与bk指向unsorted bin 的链表头</span></span><br><span class="line">         <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">           &#123;<span class="comment">//如果新的remind的size不在small bin中，而是在large bin中，则把fd_nextsize,fd_nextsize清零</span></span><br><span class="line">             remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">             remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">           &#125;  </span><br><span class="line">         set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));<span class="comment">//设置victim的chunk头</span></span><br><span class="line">         set_head (remainder, remainder_size | PREV_INUSE);<span class="comment">//设置remainder的chunk头</span></span><br><span class="line">         set_foot (remainder, remainder_size);<span class="comment">//设置remainder的物理相邻的下一个chunk的prev_size</span></span><br><span class="line">         check_malloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">         <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//将chunk指针转化为mem指针</span></span><br><span class="line">         alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>

<p>否则，将chunk从unsored bin中移除，如果大小正好合适，就将其返回给用户。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;<span class="comment">//将bin从unsortedbin中取出</span></span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;<span class="comment">//如果申请的大小转化后正好等于victim size，直接返回即可</span></span><br><span class="line">    set_inuse_bit_at_offset (victim, size);<span class="comment">//设置victim的下一个chunk的prev_inuse位</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)<span class="comment">//如果av不是主进程main_arena </span></span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//设置NON_MAIN_ARENA位              </span></span><br><span class="line">    check_malloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//将chunk指针转化为mem指针</span></span><br><span class="line">    alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果chunk大小不合适，就将其插入到对应的bin中（small bin、large bin）。。若large bin不为空，则按顺序插入。当iters大于最大的iters（10000）时，即遍历完unsorted bin，程序退出。到此第一个while内循环结束</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">        &#123;<span class="comment">//若size属于small bins，则将chunk加入到bck和fwd之间，作为small bins的第一个chunk</span></span><br><span class="line">          victim_index = smallbin_index (size);<span class="comment">//获取大小对应的索引</span></span><br><span class="line">          bck = bin_at (av, victim_index);<span class="comment">//通过 bin index 获得 bin 的链表指针</span></span><br><span class="line">          fwd = bck-&gt;fd;<span class="comment">//bck-&gt;fd 指向下一个chunk（small bin为头插法）</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">//若不在small bin的范围中，则</span></span><br><span class="line">          victim_index = largebin_index (size);<span class="comment">//获取大小对应的索引</span></span><br><span class="line">          bck = bin_at (av, victim_index);<span class="comment">//通过 bin index 获得 bin 的链表指针</span></span><br><span class="line">          fwd = bck-&gt;fd;<span class="comment">// fwd指向下一个chunk              </span></span><br><span class="line">          <span class="keyword">if</span> (fwd != bck)   <span class="comment">//若fwd不等于bck，说明large bins中存在空闲chunk</span></span><br><span class="line">  &#123;</span><br><span class="line">	size |= PREV_INUSE;<span class="comment">//将 PREV_INUSE 标志的位置设置为1</span></span><br><span class="line">	assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);	<span class="comment">//验证之前分配的内存块											  </span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">	&#123;<span class="comment">//如果当前size比最后一个chunk size还要小，则将当前size的chunk加入到chunk size链表尾</span></span><br><span class="line">		fwd = bck;<span class="comment">//fwd指向链表指针bin</span></span><br><span class="line">		bck = bck-&gt;bk;<span class="comment">//bck指向链表指针bin的上一个chunk</span></span><br><span class="line">		victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//指向链表指针bin的下一个chunk</span></span><br><span class="line">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//指向链表指针bin的下一个chunk的bk_nextsize</span></span><br><span class="line">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//下一个chunk的指针指向自己</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;<span class="comment">//否则遍历chunk size链表</span></span><br><span class="line">		assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);	<span class="comment">//验证之前分配的内存块</span></span><br><span class="line">		<span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">		&#123;<span class="comment">//正向遍历chunk size链表，找到第一个chunk大小小于等于当前大小的chunk</span></span><br><span class="line">			fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">		&#125;<span class="comment">//若已经存在相同大小的chunk，则将当前chunk插入到同大小chunk链表的尾部 								</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">			fwd = fwd-&gt;fd;					</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;<span class="comment">// 否则延伸出一个大小等于当前size的chunk链表，将该链表加入到chunk size链表尾</span></span><br><span class="line">			victim-&gt;fd_nextsize = fwd;<span class="comment">//fd_nextsize指向下一个chunk</span></span><br><span class="line">			victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//bk_nextsize指向下一个chunk的bk_nextsize</span></span><br><span class="line">			fwd-&gt;bk_nextsize = victim;<span class="comment">//下一个chunk的bk_nextsize指向自己</span></span><br><span class="line">			victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//下一个大小不同的chunk的fd_nextsize指向自己</span></span><br><span class="line">		&#125;</span><br><span class="line">		bck = fwd-&gt;bk;<span class="comment">//指向下一个chunk的上一个chunk</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//large bin为空直接将其加入</span></span><br><span class="line">            victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin (av, victim_index);<span class="comment">//标记为特定状态</span></span><br><span class="line">      victim-&gt;bk = bck;<span class="comment">//当前chunk的bk指针指向链表头</span></span><br><span class="line">      victim-&gt;fd = fwd;<span class="comment">//当前chunk的fd指针指向下一块chunk</span></span><br><span class="line">      fwd-&gt;bk = victim;<span class="comment">//下一块chunk的bk指针指向当前chunk</span></span><br><span class="line">      bck-&gt;fd = victim;<span class="comment">//链表头的fd指针指向当前chunk</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//遍历完unsorted bin退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;<span class="comment">//第一个内循环结束  </span></span><br></pre></td></tr></table></figure></div>

<p>如果用户申请的chunk是large chunk，就在第一个循环结束后搜索large bin。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))<span class="comment">//判断chunk是否位于large bins中</span></span><br><span class="line">  &#123;</span><br><span class="line">    bin = bin_at (av, idx); <span class="comment">//获取bin链表指针             </span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<span class="comment">//如果large bins不为空</span></span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))<span class="comment">//且大小满足</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;<span class="comment">//指向上一个大小不同的chunk</span></span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))<span class="comment">//遍历chunk size链表，找到大于等于所需大小的chunk链表</span></span><br><span class="line">          victim = victim-&gt;bk_nextsize;              </span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<span class="comment">//不是唯一一个large chunk</span></span><br><span class="line">          victim = victim-&gt;fd;<span class="comment">//指向victim的下一块chunk，取出chunk</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//计算剩余size</span></span><br><span class="line">        unlink (av, victim, bck, fwd);<span class="comment">//然后脱链            </span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;<span class="comment">//若剩余部分小于MIN_SIZE，则将整个chunk分配给非主分配区（内存映射区）</span></span><br><span class="line">            set_inuse_bit_at_offset (victim, size);<span class="comment">//设置inuse标志位</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">////将 NON_MAIN_ARENA 标志设置为1</span></span><br><span class="line">          &#125;            </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;<span class="comment">//否则将剩余部分作为新chunk加入到unsorted bins中</span></span><br><span class="line">            remainder = chunk_at_offset (victim, nb);<span class="comment">//获取剩余部分指针</span></span><br><span class="line">            bck = unsorted_chunks (av);<span class="comment">//获取unsorted bin链表指针</span></span><br><span class="line">            fwd = bck-&gt;fd;<span class="comment">//获取下一块unsoted chunk指针</span></span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">              &#123;<span class="comment">//安全检查，如果下一块的上一块不等于链表指针</span></span><br><span class="line">                errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">              &#125;</span><br><span class="line">            remainder-&gt;bk = bck;<span class="comment">//将 remainder插入到unsoeted bin</span></span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;<span class="comment">//如果remainder大小在large bin中，设置fd_nextsize、bk_nextsize为NULL</span></span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |<span class="comment">//设置获取到的chunk头</span></span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line"><span class="comment">//如果av不等于&amp;main_arena，则设置NON_MAIN_ARENA标志，否则设置为0</span></span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);<span class="comment">//设置remainder的chunk头</span></span><br><span class="line">            set_foot (remainder, remainder_size);<span class="comment">//设置remainder的下一块chunk的presize</span></span><br><span class="line">          &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//将chunk指针转化为mem指针</span></span><br><span class="line">        alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>接下来，进入内层第二个for循环。在small bins和large bins中都没有找到大小合适的chunk，尝试从大小比所需大小更大的空闲chunk中寻找合适的。根据binmap来搜索bin，使用binmap主要时为了加快查找空闲chunk的效率，这里只查询比所需chunk大的bin中是否有空闲chunk可用。获取下一个相邻bin的空闲chunk链表，并获取该bin对于binmap中的bit位的值，binmap中标识了相应bin中是否存在空闲chunk，按照block进行管理，每个block为一个int，共32bit，可以表示32个bin中是否存在空闲chunk。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前内存块的bin、位图映射和位索引等信息    </span></span><br><span class="line"> ++idx;<span class="comment">//将idx变量增加1</span></span><br><span class="line"> bin = bin_at (av, idx);<span class="comment">//获取bin指针</span></span><br><span class="line"> block = idx2block (idx);<span class="comment">//将当前索引idx转换为块索引</span></span><br><span class="line"> <span class="built_in">map</span> = av-&gt;binmap[block];<span class="comment">//从av分配器的binmap数组中获取指定块索引对应的位图（bitmap）映射</span></span><br><span class="line"> bit = idx2bit (idx);<span class="comment">//将当前索引idx转换为位索引</span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">for</span> (;; )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">       &#123;<span class="comment">//遍历下一个block，直到找到一个不为0的block或遍历完所有的block </span></span><br><span class="line">         <span class="keyword">do</span></span><br><span class="line">           &#123;</span><br><span class="line">             <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) </span><br><span class="line">               <span class="keyword">goto</span> use_top;</span><br><span class="line">           &#125;<span class="comment">//没有找到合适chunk，尝试使用top chunk分配</span></span><br><span class="line">         <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);    </span><br><span class="line">         bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<span class="comment">//设置bin指向block的第一个bit对应的bin </span></span><br><span class="line">         bit = <span class="number">1</span>;<span class="comment">//将bit置为1，表示该block中bit1对应的bin</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>

<p>在内层第二个循环内部，找第一个不为空的block，再根据比特位找到合适的bin。然后检查bit对应的bin是否为空，如果是，就清空对应的比特位，从下一个bin开始再次循环，否则将victim从bm中取出来。将取出的victim进行切分并把remainder加人unsorted bin，如果victim不够切分，就直接返回给用户。内层第二个循环到此结束。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;<span class="comment">//在block中遍历对应的bin，直到找到一个不为0的bit</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;    </span><br><span class="line">    victim = last (bin);<span class="comment">// 将chunk加入链表尾  </span></span><br><span class="line">    <span class="keyword">if</span> (victim == bin)<span class="comment">//若victim与bin链表头指针相同，表示该bin中没有空闲chunk</span></span><br><span class="line">      &#123;<span class="comment">//binmap中的相应位设置不准确，将其清零</span></span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        size = chunksize (victim);<span class="comment">//获得size</span></span><br><span class="line">        assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));<span class="comment">//判断chunk大小是否满足</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//计算分配后的剩余大小</span></span><br><span class="line">        unlink (av, victim, bck, fwd);<span class="comment">//脱链</span></span><br><span class="line">       <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;<span class="comment">//若剩余部分小于MIN_SIZE，则将整个chunk分配给非主分配区（内存映射区）</span></span><br><span class="line">            set_inuse_bit_at_offset (victim, size);<span class="comment">//设置inuse标志位</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">////将 NON_MAIN_ARENA 标志设置为1</span></span><br><span class="line">          &#125;            </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;<span class="comment">//否则将剩余部分作为新chunk加入到unsorted bins中</span></span><br><span class="line">            remainder = chunk_at_offset (victim, nb);<span class="comment">//获取剩余部分指针</span></span><br><span class="line">            bck = unsorted_chunks (av);<span class="comment">//获取unsorted bin链表指针</span></span><br><span class="line">            fwd = bck-&gt;fd;<span class="comment">//获取下一块unsoted chunk指针</span></span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">              &#123;<span class="comment">//安全检查，如果下一块的上一块不等于链表指针</span></span><br><span class="line">                errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;<span class="comment">//打印错误信息</span></span><br><span class="line">              &#125;</span><br><span class="line">            remainder-&gt;bk = bck;<span class="comment">//将 remainder插入到unsoeted bin</span></span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;			  </span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))<span class="comment">//若分配大小属于small bin</span></span><br><span class="line"> av-&gt;last_remainder = remainder;<span class="comment">//将last_remainder设置为剩余部分构成的chunk</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;<span class="comment">//如果remainder大小在large bin中，设置fd_nextsize、bk_nextsize为NULL</span></span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |<span class="comment">//设置获取到的chunk头</span></span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line"><span class="comment">//如果av不等于&amp;main_arena，则设置NON_MAIN_ARENA标志，否则设置为0</span></span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);<span class="comment">//设置remainder的chunk头</span></span><br><span class="line">            set_foot (remainder, remainder_size);<span class="comment">//设置remainder的下一块chunk的presize</span></span><br><span class="line">          &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//将chunk指针转化为mem指针</span></span><br><span class="line">        alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>注意以下代码，即如果找不到合适的chunk，就从top chunk上进行切分。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) </span><br><span class="line">      <span class="keyword">goto</span> use_top;</span><br><span class="line">  &#125;<span class="comment">//没有找到合适chunk，尝试使用top chunk分配</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);    </span><br></pre></td></tr></table></figure></div>

<p>如果top chunk的大小不能满足条件，且fast bins 还有 chunk，就再次调用malloc_consolidate整理fsat bins，此时会重新设置binmap中对应位置的标志位，表示该bin中有可用的空闲块。然后，重新计算索引，回到do while循环（也就是ues_top）。如果fast bins 没有 chunk了，就会调用sysmalloc申请内存。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    use_top:        </span><br><span class="line">      victim = av-&gt;top;<span class="comment">//获得top chunk指针与大小</span></span><br><span class="line">      size = chunksize (victim);<span class="comment">//获得top chunk大小    </span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;<span class="comment">//必须满足top chunk size &gt; nb + MINSIZE的情况下才能分配</span></span><br><span class="line">          remainder_size = size - nb;<span class="comment">//从top chunk分配内存后，剩余的部分将作为新的top chunk</span></span><br><span class="line">          remainder = chunk_at_offset (victim, nb);<span class="comment">//获取剩余内存指针</span></span><br><span class="line">          av-&gt;top = remainder;<span class="comment">//修改top指针</span></span><br><span class="line">          set_head (victim, nb | PREV_INUSE |<span class="comment">//设置获取到的chunk头</span></span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">		   <span class="comment">//如果av不等于&amp;main_arena，则设置NON_MAIN_ARENA标志，否则设置为0</span></span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE); <span class="comment">//设置remainder的chunk头</span></span><br><span class="line">          check_malloced_chunk (av, victim, nb);<span class="comment">//检查分配的内存块是否有效</span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//将chunk指针转化为mem指针</span></span><br><span class="line">          alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;<span class="comment">//若top chunk也无法满足要求，则检查fast bins中是否存在空闲chunk</span></span><br><span class="line">          malloc_consolidate (av);<span class="comment">//整理fast bin</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))<span class="comment">//大小在small bin中</span></span><br><span class="line">            idx = smallbin_index (nb);<span class="comment">//获取small bin的下标idx</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);<span class="comment">//否则获取large bin的下标</span></span><br><span class="line">        &#125;     </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">//所有方法都行不通，最后的解决方案是向系统申请一块新的内存 </span></span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);<span class="comment">//对分配的内存块进行初始化</span></span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-整体流程"><a href="#2-2-整体流程" class="headerlink" title="2.2 整体流程"></a>2.2 整体流程</h2><ol>
<li>如果 arena 未初始化，则调用 sysmalloc 向系统申请内存，然后返回获取的chunk </li>
<li>检查fast bins中是否有合适的chunk，如果可以在fast bins中找到一个所需大小的chunk，就从对应的 fast bin 的头部获取 chunk分配给用户，结束程序。否则转到第3步。</li>
<li>判断所需大小是否在small bins中，如果在，就根据所需分配的chunk的大小，找到具体所在的某个small bin，从该bin的尾部摘取一个恰好满足大小的chunk。若成功，则分配结束，否则，转到第4步。</li>
<li>如果fast bin、small bin都不能满足。调用 malloc_consolidate 函数将 fast bin 中的 chunk 合并后放入 unsorted bin。</li>
<li>遍历 unsorted bin 中的 chunk，如果满足条件就分配chunk后返回，否则将根据 chunk 的大小将其放入 small bins 或是 large bins 中，遍历完成后，转入第6步。(第一个大循环)在这个循环里，已经判断了chunk大小是否恰好等于申请的大小，也就是说，如果是属于small bins的申请大小，在这一步就已经成功分配了，没有分配成功则证明大小在large bins范围内。因此下一步只考虑large bins分配。</li>
<li>如果申请chunk的大小在large bins中，就从large bins中按大小顺序找一个合适的chunk，从中划分一块所需大小的chunk，并将剩下的部分链接回到unsorted bins头部。若操作成功，则分配结束，否则转到第7步。</li>
<li>在small bins和large bins中都没有找到大小合适的chunk，尝试从大小比所需大小更大的空闲chunk中寻找合适的。这一步使用binmap优化。如果所有的操作都不满足条件，就调用sysmalloc 向系统申请内存，然后返回给用户。（第二个大循环）</li>
</ol>
<p><strong>sysmalloc()函数的大概流程如下。</strong></p>
<ul>
<li>当申请的大小nb大于mp.mmap_threshold时，通过mmap()函数进行分配。其中mp_.mmap_threshold的默认大小为128×l024字节</li>
<li>尝试用brk()扩展堆内存，形成新的top chunk，而旧的top chunk会被释放。然后从新的top chunk中切分出nb大小的chunk，返回给用户</li>
</ul>
<p><strong>整体流程图如下：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h15.png?x-oss-process=style/watermark"
                     
                ></p>
<p>对第5步和第7步两个循环进行详细介绍如下：</p>
<p><strong>第一个循环：</strong></p>
<p>①首先遍历unsorted bins中每一个chunk。 </p>
<p>②如果用户的申请的大小在 small bin 范围内，且当前chunk 是last_remainder，且last_remainder是 unsorted bin中的唯一一个 chunk，且last_remainder可以切割，则从last_reminder中切下一块内存返回。否则，转到下一步。</p>
<p>③将chunk从unsored bin中移除。</p>
<p>④如果该chunk 的大小恰好等于申请的 chunk 大小，就将其返回给用户。如果大小不合适，就转到下一步。</p>
<p>⑤根据 chunk 的大小将其放入 small bin 或 large bin 中。对于 small bin 直接从链表头部加入；对于 large bin，如果链表为空，就直接加入；如果在链表尾部，就直接加入；否则遍历large size的大小，找到大小相同的，就加入该large链的尾部，否则就延伸一个large链表，加入尾部并更新nextsize指针。</p>
<p>⑥如果iters大于设置的MAX_ITERS(10000),就退出循环</p>
<p>流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wutongblogs.oss-cn-beijing.aliyuncs.com/blogs/heap/h16.png?x-oss-process=style/watermark"
                     
                ></p>
<p><strong>第二个循环：</strong></p>
<p>第二个循环是用来找一个 chunk 范围比申请 chunk 大的，即在非空 bin 里面找最后一个 chunk，这个过程用 binmap 优化。</p>
<p>①遍历每一个block，即块索引，也就是遍历每一个空闲chunk，如果没有找到合适chunk，就尝试使用top chunk分配。转到第3步。</p>
<p>②找到合适的chunk，如果不可以切分，就返回整个chunk。如果可以切分，就切分这个 chunk，剩余部分remainder在small bin范围内就放入small bin，否则放入unsorted bin，然后返回获取的 chunk 。</p>
<p>③如果 top chunk 可以切分，就切分后返回chunk，top chunk不能满足要求且fastbins中存在空闲chunk，就调用 malloc_consolidate 合并 fast bin 中的 chunk 并放入 unsorted bin 中，此时会重新设置binmap中对应位置的标志位，然后回到第1步。否则（fastbins中无空闲chunk），使用 sysmalloc 系统调用向操作系统申请内存分配 chunk 。</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 堆分配</li>
        <li><strong>Author:</strong> wutong</li>
        <li><strong>Created at:</strong> 2023-07-29 19:42:22</li>
        
            <li>
                <strong>Updated at:</strong> 2023-08-20 21:19:37
            </li>
        
        <li>
            <strong>Link:</strong> https://wutong01304.github.io/2023/07/29/heap2/
        </li>
        <li>
            <strong>License:</strong> This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Pwn/">#Pwn</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/heap/">#heap</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/Basic-Knowledge/">#Basic Knowledge</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/07/31/heap3/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">堆释放</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/07/27/heap1/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">堆基础原理</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">堆分配</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">一、堆初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-libc-malloc"><span class="nav-text">1.1 __libc_malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-malloc-consolidate"><span class="nav-text">1.2 malloc_consolidate</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%A0%86%E5%88%86%E9%85%8D"><span class="nav-text">二、堆分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">2.1 代码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-text">2.2 整体流程</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">wutong</a>
        </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br>
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.1</a>
        </div>
        
        
        
        
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>





    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>






  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>







<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
